// 设计模式


// 1、单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

// 2、策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。
// 优点
// a 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。
// b 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。
// c 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。
// d 在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案。

// 3、代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。
// 保护代理和虚拟代理
// 缓存代理
var proxyMult = (function () {
  var cache = {};
  return function () {
    var args = Array.prototype.join.call(arguments, ",");
    if (args in cache) {
      return cache[args];
    }
    return (cache[args] = mult.apply(this, arguments));
  };
})();
proxyMult( 1, 2, 3, 4 ); // 输出：24 
proxyMult( 1, 2, 3, 4 ); // 输出：24

// 4、迭代器模式
// 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象
// 的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即
// 使不关心对象的内部构造，也可以按顺序访问其中的每个元素。

// 5、发布—订阅模式
// 发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状
// 态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型
// 来替代传统的发布—订阅模式。

// 6、命令模式
// 命令模式是最简单和优雅的模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令。

// 7、组合模式
// 组合模式将对象组合成树形结构，以表示“部分整体”的层次结构。

// 8、模板方法模式
// 模板方法模式是一种只需使用继承就可以实现的非常简单的模式。
// 模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常
// 在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺
// 序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。

// 好莱坞原则

// 9、享元模式
// 享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量
// 级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。


// 10、职责链模式
// 职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间
// 的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

// 11、中介者模式
// 中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的
// 相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知
// 中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。


// 12、装饰者模式

// 装饰者模式和代理模式的差别
// 代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直
// 接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代
// 理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对
// 象动态加入行为。换句话说，代理模式强调一种关系（Proxy 与它的实体之间的关系），这种关系
// 可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确
// 定对象的全部功能时。代理模式通常只有一层代理本体的引用，而装饰者模式经常会形成一条
// 长长的装饰链。


// 13、状态模式
// 状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。

// 状态模式和策略模式的区别
// 状态模式和策略模式像一对双胞胎，它们都封装了一系列的算法或者行为，它们的类图看起来几乎一模一样，但在意图上有很大不同，因此它们是两种迥然不同的模式。

// 优点
// 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。
// 避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过多的条件分支。
// 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。
// Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。


// 14、适配器模式
// 适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本
// 由于接口不兼容而不能工作的两个软件实体可以一起工作。